---
description: 利用可能な設計アーティファクトに基づいて、実行可能で依存関係順に並べられたtasks.mdを生成します。
---

ユーザー入力は、エージェントによって直接提供されるか、コマンド引数として提供される可能性があります。**必ず**それを考慮してプロンプトを進めてください（空でない場合）。

ユーザー入力:

$ARGUMENTS

1. リポジトリのルートから`.specify/scripts/bash/check-prerequisites.sh --json`を実行し、FEATURE_DIRとAVAILABLE_DOCSリストを解析します。すべてのパスは絶対パスでなければなりません。
2. 利用可能な設計ドキュメントを読み込み、分析します:
   - 常にplan.mdを読み込み、技術スタックとライブラリを確認
   - 存在する場合: data-model.mdを読み込み、エンティティを確認
   - 存在する場合: contracts/を読み込み、APIエンドポイントを確認
   - 存在する場合: research.mdを読み込み、技術的な決定を確認
   - 存在する場合: quickstart.mdを読み込み、テストシナリオを確認

   注意: すべてのプロジェクトにすべてのドキュメントがあるわけではありません。例えば:
   - CLIツールにはcontracts/がない場合があります
   - シンプルなライブラリにはdata-model.mdが必要ない場合があります
   - 利用可能なものに基づいてタスクを生成します

3. テンプレートに従ってタスクを生成:
   - `.specify/templates/tasks-template.md`をベースとして使用
   - 例示タスクを以下に基づく実際のタスクに置き換え:
     * **セットアップタスク**: プロジェクト初期化、依存関係、リント設定
     * **テストタスク [P]**: 各契約ごとに1つ、各統合シナリオごとに1つ
     * **コアタスク**: 各エンティティ、サービス、CLIコマンド、エンドポイントごとに1つ
     * **統合タスク**: データベース接続、ミドルウェア、ロギング
     * **仕上げタスク [P]**: 単体テスト、パフォーマンス、ドキュメント

4. タスク生成ルール:
   - 各契約ファイル → [P]としてマークされた契約テストタスク
   - data-model内の各エンティティ → [P]としてマークされたモデル作成タスク
   - 各エンドポイント → 実装タスク（共有ファイルの場合は並列ではない）
   - 各ユーザーストーリー → [P]としてマークされた統合テスト
   - 異なるファイル = 並列可能 [P]
   - 同じファイル = 逐次（[P]なし）

5. 依存関係でタスクを順序付け:
   - すべての前にセットアップ
   - 実装前にテスト（TDD）
   - モデルをサービスの前に
   - サービスをエンドポイントの前に
   - コアを統合の前に
   - すべてを仕上げの前に

6. 並列実行の例を含める:
   - 一緒に実行可能な[P]タスクをグループ化
   - 実際のTaskエージェントコマンドを表示

7. FEATURE_DIR/tasks.mdを作成:
   - 実装計画から正しい機能名を取得
   - 番号付きタスク（T001、T002など）
   - 各タスクの明確なファイルパス
   - 依存関係の注記
   - 並列実行のガイダンス

タスク生成のコンテキスト: $ARGUMENTS

tasks.mdは即座に実行可能である必要があります—各タスクは、追加のコンテキストなしでLLMが完了できるほど具体的でなければなりません。
